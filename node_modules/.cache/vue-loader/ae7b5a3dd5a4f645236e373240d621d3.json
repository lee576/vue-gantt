{"remainingRequest":"D:\\IloveCode\\Gantt\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\IloveCode\\Gantt\\src\\components\\gantt\\Bar.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\IloveCode\\Gantt\\src\\components\\gantt\\Bar.vue","mtime":1646462937484},{"path":"D:\\IloveCode\\Gantt\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\IloveCode\\Gantt\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"D:\\IloveCode\\Gantt\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\IloveCode\\Gantt\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KDQppbXBvcnQgU25hcCBmcm9tICdzbmFwc3ZnLWNqcycNCmltcG9ydCBpbnRlcmFjdCBmcm9tICdpbnRlcmFjdGpzJw0KaW1wb3J0IHsgc3RvcmUgfSBmcm9tICdAL2NvbXBvbmVudHMvZ2FudHQvc3RvcmUuanMnDQpleHBvcnQgZGVmYXVsdCB7DQogIG5hbWU6ICdCYXInLA0KICBwcm9wcyA6IHsNCiAgICByb3dIZWlnaHQ6IHsNCiAgICAgIHR5cGU6IE51bWJlciwNCiAgICAgIGRlZmF1bHQ6IDANCiAgICB9LA0KICAgIHJvdzogew0KICAgICAgdHlwZTogT2JqZWN0LA0KICAgICAgZGVmYXVsdDogKCkgPT4ge30NCiAgICB9LA0KICAgIHN0YXJ0R2FudHREYXRlOiB7DQogICAgICB0eXBlOiBTdHJpbmcNCiAgICB9LA0KICAgIGVuZEdhbnR0RGF0ZTogew0KICAgICAgdHlwZTogU3RyaW5nDQogICAgfQ0KICB9LA0KCWRhdGEoKSB7DQoJCXJldHVybiB7DQogICAgICAvLyBCYXLnmoTpq5jluqbljaDlrrnlmahSb3fooYzpq5jnmoQ3MCUsIOmrmOW6pumaj+WuueWZqOihjOmrmOWPmOWMluiAjOWPmOWMlg0KICAgICAgYmFySGVpZ2h0OiB0aGlzLnJvd0hlaWdodCAqIDAuNywNCiAgICAgIGJhcldpZHRoOiAwLA0KICAgICAgLy8gcmVzaXplIOeahOaLluWKqOaWueWQkQ0KICAgICAgZGlyZWN0aW9uOiBudWxsLA0KICAgICAgb2xkQmFyRGF0YVg6IDANCiAgICB9Ow0KCX0sDQoJY29tcHV0ZWQ6IHsNCiAgICB0aW1lbGluZUNlbGxDb3VudCAoKXsNCiAgICAgIHJldHVybiBzdG9yZS50aW1lbGluZUNlbGxDb3VudA0KICAgIH0sDQogICAgc2NhbGUgKCl7DQogICAgICByZXR1cm4gc3RvcmUuc2NhbGUNCiAgICB9LA0KICAgIG1vZGUgKCkgew0KICAgICAgcmV0dXJuIHN0b3JlLm1vZGUNCiAgICB9DQogIH0sDQoJY3JlYXRlZCgpIHt9LA0KCW1vdW50ZWQoKSB7DQogICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gew0KICAgICAgdGhpcy5iYXJXaWR0aCA9IHRoaXMuc2NhbGUNCiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuc3RhcnRHYW50dERhdGUpDQogICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmVuZEdhbnR0RGF0ZSkNCg0KICAgICAgY29uc29sZS5sb2codGhpcy5tb2RlKQ0KDQogICAgICBsZXQgdGhhdCA9IHRoaXMNCiAgICAgIGNvbnN0IGJhciA9IHRoaXMuJHJlZnMuYmFyOw0KICAgICAgbGV0IHN2ZyA9IFNuYXAoYmFyKTsNCiAgICAgIA0KICAgICAgLy8g5a6a5LmJ5LiA5Liq5pac5p2h57q555qE55S756yUDQogICAgICBsZXQgcCA9IHN2Zy5wYXRoKCJNMTAtNS0xMCwxNU0xNSwwLDAsMTVNMC01LTIwLDE1IikuYXR0cih7DQogICAgICAgICAgZmlsbDogIm5vbmUiLA0KICAgICAgICAgIHN0cm9rZU9wYWNpdHk6ICcuNCcsDQogICAgICAgICAgc3Ryb2tlOiAiZ3JheSIsDQogICAgICAgICAgc3Ryb2tlV2lkdGg6IDUNCiAgICAgIH0pLnBhdHRlcm4oMCwgMCwgMTAsIDEwKQ0KICAgICAgc3ZnLnJlY3QoMCwgMCwgdGhpcy5zY2FsZSwgdGhpcy5iYXJIZWlnaHQsIDEwKS5hdHRyKHtmaWxsOiBwfSkNCiAgICAgIGxldCBnID0gc3ZnLmcoKTsNCiAgICAgIGxldCBpbm5lclJlY3QgPSBzdmcucmVjdCgwLCAwLCB0aGlzLnNjYWxlIC8gMiwgdGhpcy5iYXJIZWlnaHQsIDEwKQ0KICAgICAgLy8g5Y2K6YCP5piODQogICAgICBpbm5lclJlY3QuYXR0cih7ZmlsbDogJ3JlZCcsZmlsbE9wYWNpdHk6ICcuNCd9KQ0KICAgICAgaW5uZXJSZWN0LmF0dHIoe3dpZHRoOiB0aGlzLnNjYWxlIC8gMn0pDQogICAgICAvLyDlsYXkuK3mmL7npLrmloflrZcNCiAgICAgIGxldCB0ZXh0ID0gc3ZnLnRleHQoaW5uZXJSZWN0Lm5vZGUud2lkdGguYmFzZVZhbC52YWx1ZSAvIDIsICc1MCUnLCAiNTAlIikuYXR0cih7DQogICAgICAgICAgc3Ryb2tlOiAid2hpdGUiLA0KICAgICAgICAgIGRvbWluYW50QmFzZWxpbmU6ICdtaWRkbGUnLA0KICAgICAgICAgIGZvbnRTaXplOiAnMTVweCcNCiAgICAgIH0pOw0KICAgICAgLy8g5paH5pys5bGF5LitDQogICAgICBsZXQgeFBvc2l0aW9uID0gaW5uZXJSZWN0Lm5vZGUud2lkdGguYmFzZVZhbC52YWx1ZSAvIDIgLSB0ZXh0LmdldEJCb3goKS53aWR0aCAvIDINCiAgICAgIGlmKCB4UG9zaXRpb24gPCAwKSB7DQogICAgICAgIHRleHQuYXR0cigneCcsIGlubmVyUmVjdC5ub2RlLndpZHRoLmJhc2VWYWwudmFsdWUgLyAyKQ0KICAgICAgfSBlbHNlIHsNCiAgICAgICAgdGV4dC5hdHRyKCd4JywgeFBvc2l0aW9uKQ0KICAgICAgfQ0KICAgICAgZy5hZGQoaW5uZXJSZWN0KQ0KICAgICAgZy5hZGQodGV4dCkNCiAgICAgIA0KICAgICAgaW50ZXJhY3QoYmFyKS5kcmFnZ2FibGUoew0KICAgICAgICAgIC8vIGVuYWJsZSBpbmVydGlhbCB0aHJvd2luZw0KICAgICAgICAgIGluZXJ0aWE6IGZhbHNlLA0KICAgICAgICAgIC8vIGtlZXAgdGhlIGVsZW1lbnQgd2l0aGluIHRoZSBhcmVhIG9mICNhcHANCiAgICAgICAgICBtb2RpZmllcnM6IFsNCiAgICAgICAgICAgICAgaW50ZXJhY3QubW9kaWZpZXJzLnJlc3RyaWN0UmVjdCh7DQogICAgICAgICAgICAgICAgICByZXN0cmljdGlvbjogJ3BhcmVudCcsIC8vIHJlc3RyaWN0aW9uOiAncGFyZW50JywNCiAgICAgICAgICAgICAgICAgIGVuZE9ubHk6IHRydWUNCiAgICAgICAgICAgICAgfSkNCiAgICAgICAgICBdLA0KICAgICAgICAgIC8vIGVuYWJsZSBhdXRvU2Nyb2xsDQogICAgICAgICAgYXV0b1Njcm9sbDogdHJ1ZSwNCiAgICAgICAgICBsaXN0ZW5lcnM6IHsNCiAgICAgICAgICAgICAgLy8gY2FsbCB0aGlzIGZ1bmN0aW9uIG9uIGV2ZXJ5IGRyYWdtb3ZlIGV2ZW50DQogICAgICAgICAgICAgIG1vdmU6IGRyYWdNb3ZlTGlzdGVuZXIsDQogICAgICAgICAgICAgIC8vIGNhbGwgdGhpcyBmdW5jdGlvbiBvbiBldmVyeSBkcmFnZW5kIGV2ZW50DQogICAgICAgICAgICAgIGVuZChldmVudCkgew0KICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQNCiAgICAgICAgICAgICAgICBsZXQgeCA9IChwYXJzZUZsb2F0KHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEteCcpKSB8fCAwKSArIGV2ZW50LmR4DQogICAgICAgICAgICAgICAgLy8g56Gu5L+dIGJhciDpppblsL7msLjov5zokL3lnKjljZXlhYPmoLznmoTovrnmoYbkuIoNCiAgICAgICAgICAgICAgICBsZXQgbXVsdGlwbGUgPSBNYXRoLmZsb29yKHggLyB0aGF0LnNjYWxlKQ0KICAgICAgICAgICAgICAgIHggPSBtdWx0aXBsZSAqIHRoYXQuc2NhbGUNCiAgICAgICAgICAgICAgICBpZih4ID4gdGhhdC50aW1lbGluZUNlbGxDb3VudCAqIHRoYXQuc2NhbGUpIHsNCiAgICAgICAgICAgICAgICAgIHggPSB0aGF0LnRpbWVsaW5lQ2VsbENvdW50ICogdGhhdC5zY2FsZQ0KICAgICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgICAvLyB0cmFuc2xhdGUgdGhlIGVsZW1lbnQNCiAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0NCiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9DQogICAgICAgICAgICAgICAgICAgICd0cmFuc2xhdGUoJyArIHggKyAncHgsIDBweCknDQogICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS14JywgeCkNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgIH0sDQogICAgICB9KQ0KICAgICAgDQogICAgICBpbnRlcmFjdChiYXIpLnJlc2l6YWJsZSh7DQogICAgICAgIC8vIHJlc2l6ZSBmcm9tIGFsbCBlZGdlcyBhbmQgY29ybmVycw0KICAgICAgICBlZGdlczogeyBsZWZ0OiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiBmYWxzZSwgdG9wOiBmYWxzZSB9LA0KICAgICAgICBsaXN0ZW5lcnM6IHsNCiAgICAgICAgICBlbmQ6IChldmVudCkgPT4gew0KICAgICAgICAgICAgLy8g6K6w5L2P5pyA5YidIEJhciDnmoTlrr3luqYNCiAgICAgICAgICAgIGNvbnN0IF9iYXJXaWR0aCA9ICB0aGlzLmJhcldpZHRoDQoNCiAgICAgICAgICAgIC8vIHRoYXQucm93LnN0YXJ0X2RhdGUgPSAnMDAwMS0wMS0wMSAwMDowMDowMCcNCiAgICAgICAgICAgIC8vIHRoYXQucm93LmVuZF9kYXRlID0gJzAwMDEtMDEtMDEgMjM6NTk6NTknDQogICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0DQogICAgICAgICAgICAvL2xldCB4ID0gKHBhcnNlRmxvYXQodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS14JykpIHx8IDApDQogICAgICAgICAgICBsZXQgeCA9IDANCiAgICAgICAgICAgIC8vIOaLluWKqOeahOaYryBCYXIg55qE5Y+z6L656L6557yYDQogICAgICAgICAgICBpZihldmVudC5lZGdlcy5yaWdodCkgeyANCiAgICAgICAgICAgICAgbGV0IHJlbWFpbldpZHRoID0gZXZlbnQucmVjdC53aWR0aCAlIHRoaXMuc2NhbGUNCiAgICAgICAgICAgICAgaWYocmVtYWluV2lkdGggIT09IDApIHsNCiAgICAgICAgICAgICAgICBsZXQgbXVsdGlwbGUgPSBNYXRoLmZsb29yKGV2ZW50LnJlY3Qud2lkdGggLyB0aGlzLnNjYWxlKQ0KICAgICAgICAgICAgICAgIC8vIOaLluWIsOi2hei/h+avlOS+i+WwuuacgOWwj+WNleS9jeS4gOWNiuWuveW6pg0KICAgICAgICAgICAgICAgIGlmKHJlbWFpbldpZHRoIDwgKHRoaXMuc2NhbGUgLyAyKSkgew0KICAgICAgICAgICAgICAgICAgZXZlbnQucmVjdC53aWR0aCA9IG11bHRpcGxlICogdGhpcy5zY2FsZQ0KICAgICAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgICAgICAvLyDmi5bliLDkuI3otrPmr5TkvovlsLrmnIDlsI/ljZXkvY3kuIDljYrlrr3luqYNCiAgICAgICAgICAgICAgICAgIGV2ZW50LnJlY3Qud2lkdGggPSAobXVsdGlwbGUgKyAxKSAqIHRoaXMuc2NhbGUNCiAgICAgICAgICAgICAgICB9DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIA0KICAgICAgICAgICAgLy8g5ouW5Yqo55qE5pivIEJhciDnmoTlt6bovrnovrnnvJgNCiAgICAgICAgICAgIGlmKGV2ZW50LmVkZ2VzLmxlZnQpIHsgIA0KICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gKE1hdGguZmxvb3IoTWF0aC5hYnMoZXZlbnQucmVjdC53aWR0aCAtIF9iYXJXaWR0aCkgLyB0aGlzLnNjYWxlKSArIDEpKiB0aGlzLnNjYWxlDQogICAgICAgICAgICAgIGlmKG9mZnNldCA8IHRoaXMuc2NhbGUpIHsNCiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNjYWxlDQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgaWYgKGV2ZW50LmRlbHRhUmVjdC5sZWZ0IDwgMCkgew0KICAgICAgICAgICAgICAgIGV2ZW50LnJlY3Qud2lkdGggPSBfYmFyV2lkdGggKyBvZmZzZXQNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBlbHNlIHsNCiAgICAgICAgICAgICAgICBldmVudC5yZWN0LndpZHRoID0gX2JhcldpZHRoIC0gb2Zmc2V0DQogICAgICAgICAgICAgIH0NCiAgICAgICAgICAgICAgaWYgKGV2ZW50LnJlY3Qud2lkdGggPCB0aGlzLnNjYWxlKQ0KICAgICAgICAgICAgICAgIGV2ZW50LnJlY3Qud2lkdGggPSB0aGlzLnNjYWxlDQogICAgICAgICAgICAgIGlmIChldmVudC5yZWN0LndpZHRoID4gdGhpcy50aW1lbGluZUNlbGxDb3VudCAqIHRoaXMuc2NhbGUpDQogICAgICAgICAgICAgICAgZXZlbnQucmVjdC53aWR0aCA9IHRoaXMudGltZWxpbmVDZWxsQ291bnQgKiB0aGlzLnNjYWxlDQoNCiAgICAgICAgICAgICAgeCA9IE51bWJlcih0aGlzLm9sZEJhckRhdGFYKSAtIE51bWJlcihldmVudC5yZWN0LndpZHRoIC0gX2JhcldpZHRoKQ0KICAgICAgICAgICAgICBpZih4IDwgMCkNCiAgICAgICAgICAgICAgICB4ID0gMA0KICAgICAgICAgICAgfQ0KICAgICAgICAgICAgZWxzZSB7DQogICAgICAgICAgICAgIHggPSAocGFyc2VGbG9hdCh0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXgnKSkgfHwgMCkNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgZWxlbWVudCdzIHN0eWxlDQogICAgICAgICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSBldmVudC5yZWN0LndpZHRoICsgJ3B4Jw0KICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRhcmdldC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyB4ICsgJ3B4LCAwcHgpJw0KICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnZGF0YS14JywgeCkNCiAgICAgICAgICAgIHRhcmdldC50ZXh0Q29udGVudCA9IE1hdGgucm91bmQoZXZlbnQucmVjdC53aWR0aCkgKyAnXHUwMEQ3JyArIE1hdGgucm91bmQoZXZlbnQucmVjdC5oZWlnaHQpDQoNCiAgICAgICAgICAgIGxldCBzdmcgPSBTbmFwKGJhcik7DQogICAgICAgICAgICAvLyDlrprkuYnkuIDkuKrmlpzmnaHnurnnmoTnlLvnrJQNCiAgICAgICAgICAgIGxldCBwID0gc3ZnLnBhdGgoIk0xMC01LTEwLDE1TTE1LDAsMCwxNU0wLTUtMjAsMTUiKS5hdHRyKHsNCiAgICAgICAgICAgICAgICBmaWxsOiAibm9uZSIsDQogICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJy40JywNCiAgICAgICAgICAgICAgICBzdHJva2U6ICJncmF5IiwNCiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogNQ0KICAgICAgICAgICAgfSkucGF0dGVybigwLCAwLCAxMCwgMTApDQoNCiAgICAgICAgICAgIHN2Zy5yZWN0KDAsIDAsZXZlbnQucmVjdC53aWR0aCwgZXZlbnQucmVjdC5oZWlnaHQsIDEwKS5hdHRyKHtmaWxsOiBwfSkNCiAgICAgICAgICAgIGxldCBnID0gc3ZnLmcoKTsNCiAgICAgICAgICAgIGxldCBpbm5lclJlY3QgPSBzdmcucmVjdCgwLCAwLCBldmVudC5yZWN0LndpZHRoIC8gMiwgZXZlbnQucmVjdC5oZWlnaHQsIDEwKQ0KDQogICAgICAgICAgICAvLyDljYrpgI/mmI4NCiAgICAgICAgICAgIGlubmVyUmVjdC5hdHRyKHtmaWxsOiAncmVkJyxmaWxsT3BhY2l0eTogJy40J30pDQogICAgICAgICAgICBsZXQgdGV4dCA9IHN2Zy50ZXh0KGlubmVyUmVjdC5ub2RlLndpZHRoLmJhc2VWYWwudmFsdWUgLyAyLCAnNTAlJywgIjUwJSIpLmF0dHIoew0KICAgICAgICAgICAgICAgIHN0cm9rZTogIndoaXRlIiwJLy8g6JOd6ImyDQogICAgICAgICAgICAgICAgZG9taW5hbnRCYXNlbGluZTogJ21pZGRsZScsDQogICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNXB4Jw0KICAgICAgICAgICAgfSk7DQoNCiAgICAgICAgICAgIC8vIOaWh+acrOWxheS4rQ0KICAgICAgICAgICAgbGV0IHhQb3NpdGlvbiA9IGlubmVyUmVjdC5ub2RlLndpZHRoLmJhc2VWYWwudmFsdWUgLyAyIC0gdGV4dC5nZXRCQm94KCkud2lkdGggLyAyDQogICAgICAgICAgICBpZiggeFBvc2l0aW9uIDwgMCkgew0KICAgICAgICAgICAgICB0ZXh0LmF0dHIoJ3gnLCBpbm5lclJlY3Qubm9kZS53aWR0aC5iYXNlVmFsLnZhbHVlIC8gMikNCiAgICAgICAgICAgIH0gZWxzZSB7DQogICAgICAgICAgICAgIHRleHQuYXR0cigneCcsIHhQb3NpdGlvbikNCiAgICAgICAgICAgIH0NCiAgICAgICAgICAgIHRoaXMuYmFyV2lkdGggPSBldmVudC5yZWN0LndpZHRoDQogICAgICAgICAgICBnLmFkZChpbm5lclJlY3QpDQogICAgICAgICAgICBnLmFkZCh0ZXh0KQ0KICAgICAgICAgIH0NCiAgICAgICAgfSwNCiAgICAgICAgbW9kaWZpZXJzOiBbDQogICAgICAgICAgLy8ga2VlcCB0aGUgZWRnZXMgaW5zaWRlIHRoZSBwYXJlbnQNCiAgICAgICAgICBpbnRlcmFjdC5tb2RpZmllcnMucmVzdHJpY3RFZGdlcyh7DQogICAgICAgICAgICBvdXRlcjogJ3BhcmVudCcNCiAgICAgICAgICB9KSwNCg0KICAgICAgICAgIC8vIG1pbmltdW0gc2l6ZQ0KICAgICAgICAgIGludGVyYWN0Lm1vZGlmaWVycy5yZXN0cmljdFNpemUoew0KICAgICAgICAgICAgbWluOiB7IHdpZHRoOiB0aGlzLnNjYWxlLCBoZWlnaHQ6IHRoaXMuYmFySGVpZ2h0IH0sDQogICAgICAgICAgICBtYXg6IHsgd2lkdGg6IHRoaXMuc2NhbGUgKiB0aGlzLnRpbWVsaW5lQ2VsbENvdW50LCBoZWlnaHQ6IHRoaXMuYmFySGVpZ2h0IH0NCiAgICAgICAgICB9KQ0KICAgICAgICBdLA0KICAgICAgICBpbmVydGlhOiBmYWxzZSwNCiAgICAgICAgaG9sZDogMQ0KICAgICAgfSkNCiAgICAgIC8vIOaLluWKqOWPquaUueWPmHjovbTnmoTlnZDmoIcNCiAgICAgIGZ1bmN0aW9uIGRyYWdNb3ZlTGlzdGVuZXIoZXZlbnQpIHsNCiAgICAgICAgbGV0IHt4fSA9IGV2ZW50LnRhcmdldC5kYXRhc2V0DQogICAgICAgIHggPSAocGFyc2VGbG9hdChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXgnKSkgfHwgMCkgKyBldmVudC5keA0KICAgICAgICBPYmplY3QuYXNzaWduKGV2ZW50LnRhcmdldC5zdHlsZSwgew0KICAgICAgICAgIHdpZHRoOiBgJHtldmVudC5yZWN0LndpZHRofXB4YCwNCiAgICAgICAgICBoZWlnaHQ6IGAke2V2ZW50LnJlY3QuaGVpZ2h0fXB4YCwNCiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4fXB4LCAwcHgpYA0KICAgICAgICB9KQ0KDQogICAgICAgIGV2ZW50LnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEteCcsIHgpDQogICAgICAgIGV2ZW50LnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEteScsIDApDQogICAgICB9DQogICAgfSkNCgl9LA0KCW1ldGhvZHM6IHsNCiAgICBpc0NoaWxkT2YoY2hpbGQsIHBhcmVudCkgew0KICAgICAgaWYoY2hpbGQgJiYgcGFyZW50KSB7DQogICAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBjaGlsZC5wYXJlbnROb2RlOw0KICAgICAgICAgIHdoaWxlKHBhcmVudE5vZGUpIHsNCiAgICAgICAgICAgICAgaWYocGFyZW50ID09PSBwYXJlbnROb2RlKSB7DQogICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsNCiAgICAgICAgICAgICAgfQ0KICAgICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlOw0KICAgICAgICAgIH0NCiAgICAgIH0NCiAgICAgIHJldHVybiBmYWxzZTsNCiAgICB9LA0KICAgIG1vdXNlZW50ZXIoZXZlbnQpIHsNCiAgICAgIC8vIOiusOW9leacgOWIneeahCB46L205YC8DQogICAgICB0aGlzLm9sZEJhckRhdGFYID0gZXZlbnQuc3JjRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEteCcpDQogICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKQ0KICAgIH0NCiAgfQ0KfQ0K"},{"version":3,"sources":["Bar.vue"],"names":[],"mappings":";;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Bar.vue","sourceRoot":"src/components/gantt","sourcesContent":["<template>\r\n  <svg @mouseenter.self=\"mouseenter\" ref='bar' class=\"bar\" :width=\"barWidth + 'px'\" :height=\"barHeight + 'px'\"></svg>\r\n</template>\r\n<script>\r\nimport Snap from 'snapsvg-cjs'\r\nimport interact from 'interactjs'\r\nimport { store } from '@/components/gantt/store.js'\r\nexport default {\r\n  name: 'Bar',\r\n  props : {\r\n    rowHeight: {\r\n      type: Number,\r\n      default: 0\r\n    },\r\n    row: {\r\n      type: Object,\r\n      default: () => {}\r\n    },\r\n    startGanttDate: {\r\n      type: String\r\n    },\r\n    endGanttDate: {\r\n      type: String\r\n    }\r\n  },\r\n\tdata() {\r\n\t\treturn {\r\n      // Bar的高度占容器Row行高的70%, 高度随容器行高变化而变化\r\n      barHeight: this.rowHeight * 0.7,\r\n      barWidth: 0,\r\n      // resize 的拖动方向\r\n      direction: null,\r\n      oldBarDataX: 0\r\n    };\r\n\t},\r\n\tcomputed: {\r\n    timelineCellCount (){\r\n      return store.timelineCellCount\r\n    },\r\n    scale (){\r\n      return store.scale\r\n    },\r\n    mode () {\r\n      return store.mode\r\n    }\r\n  },\r\n\tcreated() {},\r\n\tmounted() {\r\n    this.$nextTick(() => {\r\n      this.barWidth = this.scale\r\n      // console.log(this.startGanttDate)\r\n      // console.log(this.endGanttDate)\r\n\r\n      console.log(this.mode)\r\n\r\n      let that = this\r\n      const bar = this.$refs.bar;\r\n      let svg = Snap(bar);\r\n      \r\n      // 定义一个斜条纹的画笔\r\n      let p = svg.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\r\n          fill: \"none\",\r\n          strokeOpacity: '.4',\r\n          stroke: \"gray\",\r\n          strokeWidth: 5\r\n      }).pattern(0, 0, 10, 10)\r\n      svg.rect(0, 0, this.scale, this.barHeight, 10).attr({fill: p})\r\n      let g = svg.g();\r\n      let innerRect = svg.rect(0, 0, this.scale / 2, this.barHeight, 10)\r\n      // 半透明\r\n      innerRect.attr({fill: 'red',fillOpacity: '.4'})\r\n      innerRect.attr({width: this.scale / 2})\r\n      // 居中显示文字\r\n      let text = svg.text(innerRect.node.width.baseVal.value / 2, '50%', \"50%\").attr({\r\n          stroke: \"white\",\r\n          dominantBaseline: 'middle',\r\n          fontSize: '15px'\r\n      });\r\n      // 文本居中\r\n      let xPosition = innerRect.node.width.baseVal.value / 2 - text.getBBox().width / 2\r\n      if( xPosition < 0) {\r\n        text.attr('x', innerRect.node.width.baseVal.value / 2)\r\n      } else {\r\n        text.attr('x', xPosition)\r\n      }\r\n      g.add(innerRect)\r\n      g.add(text)\r\n      \r\n      interact(bar).draggable({\r\n          // enable inertial throwing\r\n          inertia: false,\r\n          // keep the element within the area of #app\r\n          modifiers: [\r\n              interact.modifiers.restrictRect({\r\n                  restriction: 'parent', // restriction: 'parent',\r\n                  endOnly: true\r\n              })\r\n          ],\r\n          // enable autoScroll\r\n          autoScroll: true,\r\n          listeners: {\r\n              // call this function on every dragmove event\r\n              move: dragMoveListener,\r\n              // call this function on every dragend event\r\n              end(event) {\r\n                let target = event.target\r\n                let x = (parseFloat(target.getAttribute('data-x')) || 0) + event.dx\r\n                // 确保 bar 首尾永远落在单元格的边框上\r\n                let multiple = Math.floor(x / that.scale)\r\n                x = multiple * that.scale\r\n                if(x > that.timelineCellCount * that.scale) {\r\n                  x = that.timelineCellCount * that.scale\r\n                }\r\n                // translate the element\r\n                target.style.webkitTransform =\r\n                    target.style.transform =\r\n                    'translate(' + x + 'px, 0px)'\r\n                target.setAttribute('data-x', x)\r\n              }\r\n          },\r\n      })\r\n      \r\n      interact(bar).resizable({\r\n        // resize from all edges and corners\r\n        edges: { left: true, right: true, bottom: false, top: false },\r\n        listeners: {\r\n          end: (event) => {\r\n            // 记住最初 Bar 的宽度\r\n            const _barWidth =  this.barWidth\r\n\r\n            // that.row.start_date = '0001-01-01 00:00:00'\r\n            // that.row.end_date = '0001-01-01 23:59:59'\r\n            let target = event.target\r\n            //let x = (parseFloat(target.getAttribute('data-x')) || 0)\r\n            let x = 0\r\n            // 拖动的是 Bar 的右边边缘\r\n            if(event.edges.right) { \r\n              let remainWidth = event.rect.width % this.scale\r\n              if(remainWidth !== 0) {\r\n                let multiple = Math.floor(event.rect.width / this.scale)\r\n                // 拖到超过比例尺最小单位一半宽度\r\n                if(remainWidth < (this.scale / 2)) {\r\n                  event.rect.width = multiple * this.scale\r\n                } else {\r\n                  // 拖到不足比例尺最小单位一半宽度\r\n                  event.rect.width = (multiple + 1) * this.scale\r\n                }\r\n              }\r\n            }\r\n            \r\n            // 拖动的是 Bar 的左边边缘\r\n            if(event.edges.left) {  \r\n              let offset = (Math.floor(Math.abs(event.rect.width - _barWidth) / this.scale) + 1)* this.scale\r\n              if(offset < this.scale) {\r\n                offset = this.scale\r\n              }\r\n              if (event.deltaRect.left < 0) {\r\n                event.rect.width = _barWidth + offset\r\n              }\r\n              else {\r\n                event.rect.width = _barWidth - offset\r\n              }\r\n              if (event.rect.width < this.scale)\r\n                event.rect.width = this.scale\r\n              if (event.rect.width > this.timelineCellCount * this.scale)\r\n                event.rect.width = this.timelineCellCount * this.scale\r\n\r\n              x = Number(this.oldBarDataX) - Number(event.rect.width - _barWidth)\r\n              if(x < 0)\r\n                x = 0\r\n            }\r\n            else {\r\n              x = (parseFloat(target.getAttribute('data-x')) || 0)\r\n            }\r\n            // update the element's style\r\n            target.style.width = event.rect.width + 'px'\r\n            target.style.webkitTransform = target.style.transform = 'translate(' + x + 'px, 0px)'\r\n            target.setAttribute('data-x', x)\r\n            target.textContent = Math.round(event.rect.width) + '\\u00D7' + Math.round(event.rect.height)\r\n\r\n            let svg = Snap(bar);\r\n            // 定义一个斜条纹的画笔\r\n            let p = svg.path(\"M10-5-10,15M15,0,0,15M0-5-20,15\").attr({\r\n                fill: \"none\",\r\n                strokeOpacity: '.4',\r\n                stroke: \"gray\",\r\n                strokeWidth: 5\r\n            }).pattern(0, 0, 10, 10)\r\n\r\n            svg.rect(0, 0,event.rect.width, event.rect.height, 10).attr({fill: p})\r\n            let g = svg.g();\r\n            let innerRect = svg.rect(0, 0, event.rect.width / 2, event.rect.height, 10)\r\n\r\n            // 半透明\r\n            innerRect.attr({fill: 'red',fillOpacity: '.4'})\r\n            let text = svg.text(innerRect.node.width.baseVal.value / 2, '50%', \"50%\").attr({\r\n                stroke: \"white\",\t// 蓝色\r\n                dominantBaseline: 'middle',\r\n                fontSize: '15px'\r\n            });\r\n\r\n            // 文本居中\r\n            let xPosition = innerRect.node.width.baseVal.value / 2 - text.getBBox().width / 2\r\n            if( xPosition < 0) {\r\n              text.attr('x', innerRect.node.width.baseVal.value / 2)\r\n            } else {\r\n              text.attr('x', xPosition)\r\n            }\r\n            this.barWidth = event.rect.width\r\n            g.add(innerRect)\r\n            g.add(text)\r\n          }\r\n        },\r\n        modifiers: [\r\n          // keep the edges inside the parent\r\n          interact.modifiers.restrictEdges({\r\n            outer: 'parent'\r\n          }),\r\n\r\n          // minimum size\r\n          interact.modifiers.restrictSize({\r\n            min: { width: this.scale, height: this.barHeight },\r\n            max: { width: this.scale * this.timelineCellCount, height: this.barHeight }\r\n          })\r\n        ],\r\n        inertia: false,\r\n        hold: 1\r\n      })\r\n      // 拖动只改变x轴的坐标\r\n      function dragMoveListener(event) {\r\n        let {x} = event.target.dataset\r\n        x = (parseFloat(event.target.getAttribute('data-x')) || 0) + event.dx\r\n        Object.assign(event.target.style, {\r\n          width: `${event.rect.width}px`,\r\n          height: `${event.rect.height}px`,\r\n          transform: `translate(${x}px, 0px)`\r\n        })\r\n\r\n        event.target.setAttribute('data-x', x)\r\n        event.target.setAttribute('data-y', 0)\r\n      }\r\n    })\r\n\t},\r\n\tmethods: {\r\n    isChildOf(child, parent) {\r\n      if(child && parent) {\r\n          let parentNode = child.parentNode;\r\n          while(parentNode) {\r\n              if(parent === parentNode) {\r\n                  return true;\r\n              }\r\n              parentNode = parentNode.parentNode;\r\n          }\r\n      }\r\n      return false;\r\n    },\r\n    mouseenter(event) {\r\n      // 记录最初的 x轴值\r\n      this.oldBarDataX = event.srcElement.getAttribute('data-x')\r\n      event.stopPropagation()\r\n    }\r\n  }\r\n}\r\n</script>\r\n<style scoped>\r\n.bar {\r\n  position: absolute;\r\n  z-index: 100;\r\n}\r\n</style>\r\n\r\n"]}]}