{
	"version": 3,
	"sources": [
		"index.ts"
	],
	"names": [],
	"mappings": "MAcO,uCACA,uCACA,sCACA,kDACA,mCACA,qCACA,+BACA,kCACA,mDACA,qCACA,oCACA,kCACA,oCACA,uCACA,sDACA,iCACA",
	"sourcesContent": [
		"/* eslint-disable import/no-extraneous-dependencies */\nimport type * as dropEvent from '@interactjs/actions/drop/DropEvent'\nimport type * as gesture from '@interactjs/actions/gesture/plugin'\nimport type * as resize from '@interactjs/actions/resize/plugin'\nimport type * as iEvent from '@interactjs/core/InteractEvent'\nimport type * as iable from '@interactjs/core/Interactable'\nimport type * as iSet from '@interactjs/core/InteractableSet'\nimport type * as interaction from '@interactjs/core/Interaction'\nimport type * as defaults from '@interactjs/core/options'\nimport type * as scope from '@interactjs/core/scope'\nimport type * as snap from '@interactjs/modifiers/snap/pointer'\nimport type { PointerEvent as _PointerEvent } from '@interactjs/pointer-events/PointerEvent'\n\n// import module augmentations\nimport '@interactjs/actions/drag/plugin'\nimport '@interactjs/actions/drop/plugin'\nimport '@interactjs/auto-scroll/plugin'\nimport '@interactjs/auto-start/InteractableMethods'\nimport '@interactjs/auto-start/base'\nimport '@interactjs/auto-start/plugin'\nimport '@interactjs/core/events'\nimport '@interactjs/interact/index'\nimport '@interactjs/core/interactablePreventDefault'\nimport '@interactjs/core/interactions'\nimport '@interactjs/dev-tools/plugin'\nimport '@interactjs/inertia/plugin'\nimport '@interactjs/modifiers/plugin'\nimport '@interactjs/pointer-events/base'\nimport '@interactjs/pointer-events/interactableTargets'\nimport '@interactjs/reflow/plugin'\nimport '@interactjs/snappers/plugin'\n\nimport type _NativePointerEventType from './NativePointerEventType'\n\nexport type OrBoolean<T> = {\n  [P in keyof T]: T[P] | boolean;\n};\n\nexport type Element = HTMLElement | SVGElement;\nexport type Context = Document | Element;\nexport type EventTarget = Window | Document | Element;\nexport type Target = EventTarget | string;\nexport type Plugin = scope.Plugin;\nexport type Actions = scope.Actions;\nexport type ActionProps<\n  T extends scope.ActionName = ActionName\n> = interaction.ActionProps<T>;\nexport type Interactable = iable.Interactable;\n/** @internal */ export type InteractableSet = iSet.InteractableSet;\nexport type Scope = scope.Scope;\nexport type Interaction<\n  T extends scope.ActionName = ActionName\n> = interaction.Interaction<T>;\nexport type InteractionProxy<\n  T extends scope.ActionName = ActionName\n> = interaction.InteractionProxy<T>;\nexport type PointerArgProps<T extends {} = {}> = interaction.PointerArgProps<T>;\nexport type InteractEvent<\n  T extends keyof scope.ActionMap = never,\n  P extends iEvent.EventPhase = iEvent.EventPhase\n> = iEvent.InteractEvent<T, P>;\nexport type EventPhase = iEvent.EventPhase;\nexport type Options = defaults.Options;\nexport type ActionName = scope.ActionName;\nexport type SignalArgs = scope.SignalArgs;\nexport type DoPhaseArg<\n  T extends ActionName,\n  P extends EventPhase\n> = interaction.DoPhaseArg<T, P>;\nexport type DoAnyPhaseArg = interaction.DoAnyPhaseArg;\n\nexport type DragEvent = InteractEvent<'drag'>;\nexport type DropEvent = dropEvent.DropEvent;\nexport type ResizeEvent = resize.ResizeEvent;\nexport type GestureEvent = gesture.GestureEvent;\nexport type PointerEvent<T extends string = any> = _PointerEvent<T>;\n\nexport interface Point {\n  x: number\n  y: number\n}\n\nexport interface Size {\n  width: number\n  height: number\n}\n\nexport interface Rect {\n  top: number\n  left: number\n  bottom: number\n  right: number\n  width?: number\n  height?: number\n}\n\nexport type FullRect = Required<Rect>;\n\nexport type RectFunction<T extends any[]> = (...args: T) => Rect | Element;\n\nexport type RectResolvable<T extends any[]> =\n  | Rect\n  | string\n  | Element\n  | RectFunction<T>;\n\nexport type Dimensions = Point & Size;\n\nexport interface CoordsSetMember {\n  page: Point\n  client: Point\n  timeStamp: number\n}\n\nexport interface CoordsSet {\n  cur: CoordsSetMember\n  prev: CoordsSetMember\n  start: CoordsSetMember\n  delta: CoordsSetMember\n  velocity: CoordsSetMember\n}\n\nexport interface HasGetRect {\n  getRect(element: Element): Rect\n}\n\nexport interface InertiaOption {\n  resistance?: number\n  minSpeed?: number\n  endSpeed?: number\n  allowResume?: boolean\n  smoothEndDuration?: number\n}\nexport type InertiaOptions = InertiaOption | boolean;\n\nexport interface EdgeOptions {\n  top?: boolean | string | Element\n  left?: boolean | string | Element\n  bottom?: boolean | string | Element\n  right?: boolean | string | Element\n}\n\nexport type CursorChecker = (\n  action: ActionProps<ActionName>,\n  interactable: Interactable,\n  element: Element,\n  interacting: boolean\n) => string;\n\nexport interface ActionMethod<T> {\n  (this: Interactable): T\n  // eslint-disable-next-line no-undef\n  (this: Interactable, options: Partial<OrBoolean<T>> | boolean): typeof this\n}\n\nexport interface OptionMethod<T> {\n  (this: Interactable): T\n  // eslint-disable-next-line no-undef\n  (this: Interactable, options: T): typeof this\n}\n\nexport type PerActionDefaults = defaults.PerActionDefaults;\nexport type OptionsArg = defaults.OptionsArg;\n\nexport interface DraggableOptions extends PerActionDefaults {\n  startAxis?: 'x' | 'y' | 'xy'\n  lockAxis?: 'x' | 'y' | 'xy' | 'start'\n  oninertiastart?: ListenersArg\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport interface DropzoneOptions extends PerActionDefaults {\n  accept?:\n  | string\n  | Element\n  | (({\n    dropzone,\n    draggableElement,\n  }: {\n    dropzone: Interactable\n    draggableElement: Element\n  }) => boolean)\n  // How the overlap is checked on the drop zone\n  overlap?: 'pointer' | 'center' | number\n  checker?: DropFunctionChecker\n\n  ondropactivate?: ListenersArg\n  ondropdeactivate?: ListenersArg\n  ondragenter?: ListenersArg\n  ondragleave?: ListenersArg\n  ondropmove?: ListenersArg\n  ondrop?: ListenersArg\n}\n\nexport type DropFunctionChecker = (\n  dragEvent: any, // related drag operation\n  event: any, // touch or mouse EventEmitter\n  dropped: boolean, // default checker result\n  dropzone: Interactable, // dropzone interactable\n  dropElement: Element, // drop zone element\n  draggable: Interactable, // draggable's Interactable\n  draggableElement: Element // dragged element\n) => boolean;\n\nexport interface ResizableOptions extends PerActionDefaults {\n  square?: boolean\n  preserveAspectRatio?: boolean\n  edges?: EdgeOptions | null\n  axis?: 'x' | 'y' | 'xy' // deprecated\n  invert?: 'none' | 'negate' | 'reposition'\n  margin?: number\n  squareResize?: boolean\n  oninertiastart?: ListenersArg\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport interface GesturableOptions extends PerActionDefaults {\n  onstart?: ListenersArg\n  onmove?: ListenersArg\n  onend?: ListenersArg\n}\n\nexport type ActionChecker = (\n  pointerEvent: any,\n  defaultAction: string,\n  interactable: Interactable,\n  element: Element,\n  interaction: Interaction\n) => ActionProps;\n\nexport type OriginFunction = (target: Element) => Rect;\nexport type SnapFunction = snap.SnapFunction;\nexport type SnapTarget = snap.SnapTarget;\n\nexport interface PointerEventsOptions {\n  holdDuration?: number\n  allowFrom?: string\n  ignoreFrom?: string\n  origin?: Rect | Point | string | Element | OriginFunction\n}\n\nexport type RectChecker = (element: Element) => Rect;\n\nexport type NativePointerEventType = typeof _NativePointerEventType;\nexport type PointerEventType =\n  | MouseEvent\n  | TouchEvent\n  | NativePointerEventType\n  | PointerEvent\n  | InteractEvent;\nexport type PointerType =\n  | MouseEvent\n  | Touch\n  | NativePointerEventType\n  | PointerEvent\n  | InteractEvent;\n\nexport type EventTypes = string | ListenerMap | Array<string | ListenerMap>;\n\nexport type Listener = (...args: any[]) => any;\nexport type Listeners = ListenerMap | ListenerMap[];\nexport type ListenersArg =\n  | Listener\n  | ListenerMap\n  | Array<Listener | ListenerMap>;\nexport interface ListenerMap {\n  [index: string]: ListenersArg | ListenersArg[]\n}\n\nexport type ArrayElementType<T> = T extends Array<infer P> ? P : never;\n"
	]
}